defmodule Vickrey.Analysis do
    @moduledoc """
    With returned data from the DB, create aggregations and calcs.
    """

    alias Vickrey.{Repo, Query}

    def get_3_letter_open_auctions(), do: Query.get_auctions_by_name_and_type("OPEN", 3)

    def get_3_letter_bid_auctions(), do: Query.get_auctions_by_name_and_type("BID", 3)

    @doc """
    Calculates the difference in between the most recent buy and sell of a given name.
    If it hasn't been sold (there is no "TRANSFER" or "FINALIZE" on the blockchain), then return an error.
    """
    def build_history(name) when is_binary(name) do
      with {:ok, chain_hist} <- get_chain_history(name),
          {:ok, nb_hist} <- get_nb_history(name) do
            zip_history(chain_hist, nb_hist)
          end
    end

    def get_chain_history(name) do
      hist = name
        |> Query.get_name_closed()
        |> Repo.all()
        |> Enum.reverse()

      case hist do
        [] -> {:error, "No on-chain history found."}
        _ -> {:ok, hist}
      end
    end

    def get_nb_history(name) do
      hist = name
        |> Query.get_sold()
        |> Repo.all()

        case hist do
          [] -> {:error, "No Namebase sale history found."}
          _ -> {:ok, hist}
        end
    end

    def zip_history(chain_hist, nb_hist) do
      chain_hist ++ nb_hist
      |> Enum.reverse()
      # TODO map ts to height and sort
    end

    @doc """
    Calculate the returns generated by a given list of transactions.
    When the list of txs is empty, we return the accumulated state of sales.
    We are erroring on a lack of history above, so this second function head should only be called at the end of recursing through the txs.
    """
    def calc_return([tx | tail], state) do
      case tx.action == "SOLD" do
        false -> calc_return(tail, state)
        true -> calc_profit(tx, tail) |> calc_return(tail, state)
      end
    end

    def calc_return([], state), do: state

    @doc """
    If our calc_return/2 recurses with an {:ok, ...} tuple, we've found a basis for our sold tx, and append the new sale data to the state, returning the tail to continue processing.
    """
    def calc_return({:ok, profit}, tail, state) do
      calc_return(tail, state ++ [profit])
    end

    @doc """
    If we get two sells in a row, we ignore the first, since we can't calculate a basis, and start a new calc from the new sold tx.
    In the second function head, we get anything else than a sell (a REGISTER, TRANSFER, OR FINALIZE), so we use that as our basis, and calculate the profit between the two txs.
    Returns a tuple with the sell object to be appended to the state upstream.
    """
    def calc_profit(%{action: "SOLD"}, [%{action: "SOLD"} = next | tail]) do
        calc_profit(next, tail)
    end

    def calc_profit(%{action: "SOLD", value: value, name: name, created_at: date}, [next | _tail]) do
      sold_value = value |> div(1_000_000)
      basis = trunc(next.value)
      {:ok, %{name: name, basis: basis, sold: sold_value, sold_time: date, profit: sold_value - basis}}
    end

    def sold_3_letter() do
      Query.get_names_sold_distinct()
      |> Query.filter_by_char_length(3)
      |> Repo.all()
      |> Enum.map(fn name -> build_history(name) end)
    end
end
